# Paths 
PathToRaw = '../data/input/samples/'
PathToRef = '../data/input/reference/'
mitoName = config['mitoName']
PathToMitochondria = '../data/temp/mitochondria/'
Mitochondria = f'../data/temp/mitochondria/{mitoName}.fasta'
PathToGtf = '../data/input/gtf/'
PathToRefTemp = '../data/temp/reference/'
PathToTemp = '../data/temp/'
PathToOutput = '../data/output/'
PathToEnv = 'environment/env.yml'
ReferenceName = config['referenceName']
GtfName = config['gtfName']


rule index_genome:
    input:
        ancient(PathToRefTemp + f"{ReferenceName}.fasta")
    output:
        bwa_index = PathToRefTemp + f"{ReferenceName}.fasta.bwt",
        fai_index = PathToRefTemp + f"{ReferenceName}.fasta.fai",
        dictionary = PathToRefTemp + f"{ReferenceName}.dict"
    conda:
        PathToEnv
    shell:
        """
        bwa index -a bwtsw {input}
        samtools faidx {input}
        gatk CreateSequenceDictionary -R {input} 
        """

rule index_mito:
    input:
        ancient(PathToMitochondria + f"{mitoName}.fasta")
    output:
        bwa_index = PathToMitochondria + f"{mitoName}.fasta.bwt",
        fai_index = PathToMitochondria + f"{mitoName}.fasta.fai",
        dictionary = PathToMitochondria + f"{mitoName}.dict"
    conda:
        PathToEnv
    shell:
        """
        bwa index -a bwtsw {input}
        samtools faidx {input}
        gatk CreateSequenceDictionary -R {input} 
        """

if not config['star']:
    rule mapping_bwa_fastq:
        input:
            paz = ancient(PathToTemp + "{sample}/"),
            reference = ancient(PathToRefTemp + f"{ReferenceName}.fasta"),
            
            R1 = ancient(PathToRaw + "{sample}_R1.fastq"),
            R2 = ancient(PathToRaw + "{sample}_R2.fastq")
        params:
            thread = config['thread']
        output:
            PathToTemp + "{sample}/{sample}.bam"
        conda:
            PathToEnv
        shell:
            """
            bwa mem -t {params.thread} {input.reference} {input.R1} {input.R2} | samtools view -@ 4 -bh | samtools sort -@ 4 -o {output}
            """


    rule mapping_bwa_gz:
        input:
            paz = ancient(PathToTemp + "{sample}/"),
            reference = ancient(PathToRefTemp + f"{ReferenceName}.fasta"),
            
            R1 = ancient(PathToRaw + "{sample}_R1.fastq.gz"),
            R2 = ancient(PathToRaw + "{sample}_R2.fastq.gz")
        params:
            thread = config['thread']
        output:
            PathToTemp + "{sample}/{sample}.bam"
        conda:
            PathToEnv
        shell:
            """
            bwa mem -t {params.thread} {input.reference} {input.R1} {input.R2} | samtools view -@ 4 -bh | samtools sort -@ 4 -o {output}
            """

    rule extract_mito:
        input:
            ancient(PathToTemp + "{sample}/{sample}.bam")
        output:
            PathToTemp + "{sample}/{sample}.mito.bam"
        conda:
            PathToEnv
        shell:
            """
            samtools index {input}
            samtools view {input} chrM -bh > {output}
            """

else:
    rule index_star:
            input:
                reference = ancient(PathToRefTemp + f"{ReferenceName}.fasta"),
                gtf = ancient(PathToGtf + f"{GtfName}.gtf"),
                genomeDir = ancient(PathToTemp + "genomeDir")
            params:
                thread = config['thread']
            output:
                PathToTemp + "genomeDir/SA"
            conda:
                PathToEnv
            shell:
                """
                STAR --runThreadN {params.thread} \
                --runMode genomeGenerate \
                --genomeDir {input.genomeDir} \
                --genomeFastaFiles {input.reference} \
                --sjdbGTFfile {input.gtf} \
                --sjdbOverhang 99 \
                """
    

    rule mapping_star_fastq:
            input:
                ancient(PathToTemp + "genomeDir/SA"),
                genomeDir = ancient(PathToTemp + "genomeDir"),
                R1 = ancient(PathToRaw + "{sample}_R1.fastq"),
                R2 = ancient(PathToRaw + "{sample}_R2.fastq")
            params:
                thread = config['thread'],
                paz = PathToTemp + "{sample}/{sample}.",
            output:
                PathToTemp + "{sample}/{sample}.bam"
            conda:
                PathToEnv
            shell:
                """
                STAR --runThreadN {params.thread} --genomeDir {input.genomeDir} --readFilesIn {input.R1} {input.R2} --outSAMmapqUnique 255 --outFileNamePrefix {params.paz} --twopassMode Basic --outSAMtype BAM SortedByCoordinate
                mv {params.paz}Aligned.sortedByCoord.out.bam {output}
                """


    rule mapping_star_gz:
            input:
                ancient(PathToTemp + "genomeDir/SA"),
                genomeDir = ancient(PathToTemp + "genomeDir"),
                R1 = ancient(PathToRaw + "{sample}_R1.fastq.gz"),
                R2 = ancient(PathToRaw + "{sample}_R2.fastq.gz")
            params:
                thread = config['thread'],
                paz = PathToTemp + "{sample}/{sample}.",
            output:
                PathToTemp + "{sample}/{sample}.bam"
            conda:
                PathToEnv
            shell:
                """
                STAR --runThreadN {params.thread} --genomeDir {input.genomeDir} --readFilesIn {input.R1} {input.R2} --outFileNamePrefix {params.paz} --outSAMmapqUnique 255 --readFilesCommand gunzip -c --twopassMode Basic --outSAMtype BAM SortedByCoordinate
                mv {params.paz}Aligned.sortedByCoord.out.bam {output}
                """
            
    rule extract_mito:
        input:
            ancient(PathToTemp + "{sample}/{sample}.bam")
        output:
            PathToTemp + "{sample}/{sample}.mito.bam"
        conda:
            PathToEnv
        shell:
            """
            samtools index {input}
            samtools view {input} NC_012920.1 -bh > {output}
            """


rule add_groups:
    input:
        bam = ancient(PathToTemp + "{sample}/{sample}.mito.bam")
    output:
        bam = PathToTemp + "{sample}/{sample}.groups.bam"
    params:
        name = "{sample}"
    conda:
        PathToEnv
    shell:
        "picard AddOrReplaceReadGroups -I {input.bam} -O {output.bam} -RGLB lib.HSmt -RGPL illumina -RGPU NO_GROUP -RGSM {params.name}"


rule sort:
    input:
        ancient(PathToTemp + "{sample}/{sample}.groups.bam")
    output:
        PathToTemp + "{sample}/{sample}.sorted.bam"
    conda:
        PathToEnv
    shell:
        "picard FixMateInformation -I {input} -O {output} -SO coordinate"


rule split_cigar:
    input:
        ancient(PathToMitochondria + f"{mitoName}.fasta.fai"),
        bam = ancient(PathToTemp + "{sample}/{sample}.sorted.bam"),
        reference = ancient(Mitochondria)
    output:
        PathToTemp + "{sample}/{sample}.ready.bai",
        bam = PathToTemp + "{sample}/{sample}.ready.bam"
    conda:
        PathToEnv
    shell:
        "gatk SplitNCigarReads -R {input.reference} -I {input.bam} -O {output.bam}"


if config['consensus']:
    rule consensus:
        input:
            ancient(PathToTemp + "{sample}/{sample}.ready.bai"),
            reference = ancient(Mitochondria),
            target_bam = ancient(PathToTemp + "{sample}/{sample}.ready.bam")
        output:
            PathToTemp + "{sample}/{sample}.fasta"
        conda:
            PathToEnv
        shell:
            "samtools consensus -f fasta -a {input.target_bam} -o {output}"
    

    rule find_haplogroup_consensus:
        input:
            result = ancient(PathToTemp + "{sample}/{sample}.fasta"),
            the_dir = ancient(PathToTemp + "{sample}")
        output:
            PathToOutput + "{sample}.txt"
        params:
            keep = config['keep']
        conda:
            PathToEnv
        shell:
            """
            haplogrep classify --in {input.result} --out {output} --format fasta
            if [ "{params.keep}" = "False" ] ; then rm -rf {input.the_dir} ; fi
            """

else:
    if not config['star']:
        rule variant_calling:
            input:
                ancient(PathToTemp + "{sample}/{sample}.ready.bai"),
                ancient(PathToMitochondria + f"{mitoName}.fasta.fai"),
                reference = ancient(Mitochondria),
                target_bam = ancient(PathToTemp + "{sample}/{sample}.ready.bam")
            output:
                PathToTemp + "{sample}/{sample}.vcf"
            params:
                thread = config['thread']
            conda:
                PathToEnv
            shell:
                "gatk Mutect2 -L chrM --mitochondria-mode --native-pair-hmm-threads {params.thread} -R {input.reference} -I {input.target_bam} -O {output}"
    else:
        rule variant_calling:
            input:
                ancient(PathToTemp + "{sample}/{sample}.ready.bai"),
                ancient(PathToMitochondria + f"{mitoName}.fasta.fai"),
                reference = ancient(Mitochondria),
                target_bam = ancient(PathToTemp + "{sample}/{sample}.ready.bam")
            output:
                PathToTemp + "{sample}/{sample}.vcf"
            params:
                thread = config['thread']
            conda:
                PathToEnv
            shell:
                "gatk Mutect2 -L NC_012920.1 --mitochondria-mode --native-pair-hmm-threads {params.thread} -R {input.reference} -I {input.target_bam} -O {output}"

    rule variant_filter:
        input:
            vcf = ancient(PathToTemp + "{sample}/{sample}.vcf"),
            reference = ancient(Mitochondria),
        output:
            PathToTemp + "{sample}/{sample}.filtered.vcf"
        conda:
            PathToEnv
        shell:
            "gatk FilterMutectCalls --mitochondria-mode -R {input.reference} -V {input.vcf} -O {output}"


    rule find_haplogroup_vcf:
        input:
            vcf = ancient(PathToTemp + "{sample}/{sample}.filtered.vcf"),
            the_dir = ancient(PathToTemp + "{sample}")
        output:
            PathToOutput + "{sample}.txt"
        params:
            keep = config['keep']
        conda:
            PathToEnv
        shell:
            """
            haplogrep classify --in {input.vcf} --out {output} --format vcf
            if [ "{params.keep}" = "False" ] ; then rm -rf {input.the_dir} ; fi
            """
